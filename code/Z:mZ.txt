// Given two coprime integers n,m computes multiplications in Z/nmZ.
// The program computes, by explicitly exploiting the isomorphism induced
// by the CRT (Chinese Remainder Theorem) between Z/nmZ and Z/nZ + Z/mZ,
// multiplications of elements in Z/nmZ.
// This can be written in a shorter way by avoiding to construct ideals and
// quotient algebras.
// Written by Alex Pellegrini.

// Generate the ring of integers.
Z := Integers();

// Read n,m and check co-primality and compute the product.
n := 3;
m := 6;
if not IsCoprime(n,m) then
   exit;
end if;
nm := n*m;

// Create the ideals generated by n and m.
nZ := ideal<Z | n>;
mZ := ideal<Z | m>;

// Build the quotient algebras (rings).
ZnZ := quo<Z | nZ>;
ZmZ := quo<Z | mZ>;

// Compute the inverse of n modulo m as required by CRT.
invN := InverseMod(n,m);
unity := n*invN;

// Read the two number to be multiplied.
x := 4;
y := 14;

// Reduce each of them on both the quotient algebras.
X := <ZnZ ! x, ZmZ ! x>;
Y := <ZnZ ! y, ZmZ ! y>;

// Compute the product in both quotient algebras.
XY := <X[1]*Y[1],X[2]*Y[2]>;

// We don't want zeroes now.
col := n;
row := m;
if XY[1] ne 0 then
   col := Z ! XY[1];
end if;
if XY[2] ne 0 then
   row := Z ! XY[2];
end if;

// Instead of computing the entire multiplication table (computational cost O(nm))
// we look directly for the result by cmputing the required column (computational cost O(m)).
result := col;
while result mod m ne XY[2] do
      result +:= unity; 
end while; 

result mod nm;

